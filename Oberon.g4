grammar Oberon;

// Лексические правила
OF: 'OF';
END: 'END';
PROCEDURE: 'PROCEDURE';
TO: 'TO';
OR: 'OR';
DIV: 'DIV';
MOD: 'MOD';
NIL: 'NIL';
TRUE: 'TRUE';
FALSE: 'FALSE';
IF: 'IF';
THEN: 'THEN';
ELSIF: 'ELSIF';
ELSE: 'ELSE';
CASE: 'CASE';
WHILE: 'WHILE';
DO: 'DO';
FOR: 'FOR';
BY: 'BY';
BEGIN: 'BEGIN';
RETURN: 'RETURN';
CONST: 'CONST';
TYPE: 'TYPE';
VAR: 'VAR';
MODULE: 'MODULE';
STRING: '"' .*? '"';
IDENT: LETTER (LETTER | DIGIT)*;
NUMBER: DIGIT+;
REAL: DIGIT+ '.' DIGIT*;

fragment LETTER: [a-zA-Z];
fragment DIGIT: [0-9];

COMMENT: '(*' .*? '*)' -> skip;
WS: [ \t\r\n] -> skip;

// Синтаксические правила
ident: IDENT;
qualident: ident;
identdef: ident '*'?;
integer: NUMBER;
real: REAL;
number: integer | real;
constDeclaration: identdef '=' constExpression;
constExpression: expression;
typeDeclaration: identdef '=' type_;
type_: qualident | arrayType;
arrayType: ARRAY length OF type_;
length: constExpression;
identList: identdef (',' identdef)*;
variableDeclaration: identList ':' type_;
expression: simpleExpression (relation simpleExpression)?;
relation: '=' | '#' | '<' | '<=' | '>' | '>=';
simpleExpression: ('+' | '-')? term (addOperator term)*;
addOperator: '+' | '-' | OR;
term: factor (mulOperator factor)*;
mulOperator: '*' | '/' | DIV | MOD | '&';
factor: number | STRING | NIL | TRUE | FALSE | set_ | designator (actualParameters)? | '(' expression ')' | '~' factor;
designator: qualident selector*;
selector: '[' expList ']' | '.' ident;
set_: '{' (element (',' element)*)? '}';
element: expression ('..' expression)?;
expList: expression (',' expression)*;
actualParameters: '(' expList? ')';
argumentList: expression (',' expression)*;
statement: (assignment | ifStatement | whileStatement | forStatement | procedureCall | returnStatement)?;
procedureCall: IDENT '(' argumentList? ')';
repeatStatement: 'REPEAT' expression 'UNTIL' statementSequence 'END';
assignment: designator ':=' expression;
statementSequence: statement (';' statement)*;
ifStatement: IF expression THEN statementSequence (ELSIF expression THEN statementSequence)* (ELSE statementSequence)? END;
whileStatement: WHILE expression DO statementSequence (ELSIF expression DO statementSequence)* END;
forStatement: FOR ident ':=' expression TO expression (BY constExpression)? DO statementSequence END;
returnStatement: RETURN expression?;
declarationSequence: (CONST (constDeclaration ';')*)? (TYPE (typeDeclaration ';')*)? (VAR (variableDeclaration ';')*)? (procedureDeclaration ';')*);
procedureDeclaration: PROCEDURE procedureHeading procedureBody ident;
procedureHeading: identdef formalParameters (':' qualident)?;
formalParameters: '(' (formalParameterList (';' formalParameterList)*)? ')';
formalParameterList: '(' identList ':' type_ ')';
procedureBody: declarationSequence BEGIN statementSequence? END;
module: MODULE ident ';' declarationSequence (BEGIN statementSequence)? RETURN factor ';' END ident '.' EOF;